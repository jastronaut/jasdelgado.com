<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="https://cdn.glitch.global/534e046c-213b-4d5a-914f-a9ac337c7b64/favicon.ico?v=1652907914971" />
    <title>Jas Delgado</title>

    <link rel="canonical" href="https://glitch-hello-website.glitch.me/" />
    <meta name="description" content="Jas Delgado's Personal Website" />
    <meta name="robots" content="index,follow" />
    <meta property="og:title" content="Jas Delgado" />
    <meta property="og:type" content="article" />
    <meta
      property="og:description"
      content="A simple website, built with Glitch. Remix it to get your own."
    />
    <meta property="og:image" content="Jas Delgado's Personal Website" />
    <meta name="twitter:card" content="summary" />

    <link rel="stylesheet" href="/style.css" />
  </head>
  <body>
    <div class="wrapper">
      <div class="content" role="main">
        <img
          class="main-img"
          src="https://cdn.glitch.global/534e046c-213b-4d5a-914f-a9ac337c7b64/001.png?v=1652888108338"
          alt="a dog in The Sims 4 named Whopper"
        />
        <h1>jas delgado</h1>
        <p>
          <a href="http://github.com/jastronaut" title="github">github</a>| <a href="https://blog.jasdelgado.com" title="blog">blog</a> | <a href="mailto:jastronaut@protonmail.com" title="email">email</a>
        </p>
      </div>
      <div id="heartScene"></div>
    </div>
    <script
      async
      src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
    ></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.140.2/build/three.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      const LIGHT_PINK = 0xedf3f5;
      const SEAFOAM_GREEN = 0x88aaaa;

      let container;
      let camera, scene, renderer;
      let group;
      let targetRotation = 0;
      let targetRotationOnPointerDown = 0;
      let pointerX = 0;
      let pointerXOnPointerDown = 0;
      let windowHalfX = window.innerWidth / 2;
      init();
      animate();

      function init() {
        container = document.querySelector("#heartScene");
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2d2d2d);
        camera = new THREE.PerspectiveCamera(
          50,
          // window.innerWidth / window.innerHeight,
          1,
          1,
          // 1000
          2000
        );
        camera.position.set(0, 150, 500);
        scene.add(camera);
        const light = new THREE.PointLight(0xedf3f5, 0.8);
        camera.add(light);
        group = new THREE.Group();
        group.position.y = 50;
        scene.add(group);

        const loader = new THREE.TextureLoader();
        const texture = loader.load(
          "https://cdn.glitch.global/534e046c-213b-4d5a-914f-a9ac337c7b64/test%3Atest.png?v=1652891744891"
        );

        // it's necessary to apply these settings in order to correctly display the texture on a shape geometry

        texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
        texture.repeat.set(0.01, 0.01);
        texture.offset.set(0.4, 0.01);
        // texture.center.set(0.5,0.5);

        function addLineShape(shape, color, x, y, z, rx, ry, rz, s) {
          // lines
          shape.autoClose = true;
          const points = shape.getPoints();
          const spacedPoints = shape.getSpacedPoints(50);
          const geometryPoints = new THREE.BufferGeometry().setFromPoints(
            points
          );
          const geometrySpacedPoints = new THREE.BufferGeometry().setFromPoints(
            spacedPoints
          );
          // solid line
          let line = new THREE.Line(
            geometryPoints,
            new THREE.LineBasicMaterial({ color: color })
          );
          line.position.set(x, y, z - 25);
          line.rotation.set(rx, ry, rz);
          line.scale.set(s, s, s);
          group.add(line);
          // line from equidistance sampled points
          line = new THREE.Line(
            geometrySpacedPoints,
            new THREE.LineBasicMaterial({ color: LIGHT_PINK })
          );
          line.position.set(x, y, z + 25);
          line.rotation.set(rx, ry + 6, rz);
          line.scale.set(s, s, s);
          group.add(line);
          // vertices from real points
          let particles = new THREE.Points(
            geometryPoints,
            new THREE.PointsMaterial({ color: color, size: 4 })
          );
          particles.position.set(x, y, z + 75);
          particles.rotation.set(rx + 50, ry, rz);
          particles.scale.set(s, s, s);
          group.add(particles);
          // equidistance sampled points
          particles = new THREE.Points(
            geometrySpacedPoints,
            new THREE.PointsMaterial({ color: SEAFOAM_GREEN, size: 4 })
          );
          particles.position.set(x, y, z + 125);
          particles.rotation.set(rx, ry + 100, rz);
          particles.scale.set(s, s, s);
          group.add(particles);
        }

        function addShape(
          shape,
          extrudeSettings,
          color,
          x,
          y,
          z,
          rx,
          ry,
          rz,
          s
        ) {
          // flat shape with texture
          // note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices
          let geometry = new THREE.ShapeGeometry(shape);
          let mesh = new THREE.Mesh(
            geometry,
            new THREE.MeshPhongMaterial({
              side: THREE.DoubleSide,
              map: texture,
            })
          );

          mesh.rotation.set(-0.5, -0.1, 0.8);

          const radiansPerSecond = THREE.MathUtils.degToRad(30);

          mesh.tick = (delta) => {
            // increase the cube's rotation each frame
            mesh.rotation.z += delta * radiansPerSecond;
            mesh.rotation.x += delta * radiansPerSecond;
            mesh.rotation.y += delta * radiansPerSecond;
          };

          mesh.position.set(x, y, z - 175);
          // mesh.rotation.set(rx, ry + 5, rz);
          mesh.scale.set(s, s, s);
          group.add(mesh);

          // flat shape
          // geometry = new THREE.ShapeGeometry(shape);
          // mesh = new THREE.Mesh(
          //   geometry,
          //   new THREE.MeshPhongMaterial({
          //     color: color,
          //     side: THREE.DoubleSide,
          //   })
          // );
          // mesh.position.set(x, y, z - 125);
          // mesh.rotation.set(rx, ry + 10, rz);
          // mesh.scale.set(s, s, s);
          // group.add(mesh);

          // extruded shape 2
          geometry = new THREE.ExtrudeGeometry(shape, {
            ...extrudeSettings,
            depth: 10,
          });
          mesh = new THREE.Mesh(
            geometry,
            new THREE.MeshPhongMaterial({ color: color })
          );
          mesh.position.set(x, y, z - 125);
          // mesh.rotation.set(rx, ry, rz);
          mesh.rotation.set(rx, ry + 270, rz);
          mesh.scale.set(s, s, s);
          group.add(mesh);

          // extruded shape
          geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
          mesh = new THREE.Mesh(
            geometry,
            new THREE.MeshPhongMaterial({ color: 0xf56c77 })
          );
          mesh.position.set(x, y, z - 75);
          // mesh.rotation.set(rx, ry, rz);
          mesh.rotation.set(rx, ry + 90, rz);
          mesh.scale.set(s * 0.5, s * 0.5, s * 0.5);
          group.add(mesh);

          shape.autoClose = true;
        }

        // Heart
        const x = 0,
          y = 0;
        const heartShape = new THREE.Shape()
          .moveTo(x + 25, y + 25)
          .bezierCurveTo(x + 25, y + 25, x + 20, y, x, y)
          .bezierCurveTo(x - 30, y, x - 30, y + 35, x - 30, y + 35)
          .bezierCurveTo(x - 30, y + 55, x - 10, y + 77, x + 25, y + 95)
          .bezierCurveTo(x + 60, y + 77, x + 80, y + 55, x + 80, y + 35)
          .bezierCurveTo(x + 80, y + 35, x + 80, y, x + 50, y)
          .bezierCurveTo(x + 35, y, x + 25, y + 25, x + 25, y + 25);

        const extrudeSettings = {
          depth: 5,
          bevelEnabled: true,
          bevelSegments: 2,
          steps: 2,
          bevelSize: 1,
          bevelThickness: 1,
        };

        addShape(
          heartShape,
          extrudeSettings,
          0xf00000,
          100,
          100,
          0,
          // 0,
          0,
          0,
          Math.PI,
          1
        );

        addLineShape(heartShape, 0xf00000, 50, 50, 0, 0, 0, Math.PI, 1);

        // etc

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0xffffff, 0);
        renderer.setSize(500, 500);
        container.appendChild(renderer.domElement);
        container.style.touchAction = "none";
        container.addEventListener("pointerdown", onPointerDown);
        // window.addEventListener("resize", onWindowResize);
      }

      function onWindowResize() {
        windowHalfX = window.innerWidth / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onPointerDown(event) {
        if (event.isPrimary === false) return;

        pointerXOnPointerDown = event.clientX - windowHalfX;
        targetRotationOnPointerDown = targetRotation;

        document.addEventListener("pointermove", onPointerMove);
        document.addEventListener("pointerup", onPointerUp);
      }

      function onPointerMove(event) {
        if (event.isPrimary === false) return;

        pointerX = event.clientX - windowHalfX;

        targetRotation =
          targetRotationOnPointerDown +
          (pointerX - pointerXOnPointerDown) * 0.02;
      }

      function onPointerUp() {
        if (event.isPrimary === false) return;

        document.removeEventListener("pointermove", onPointerMove);
        document.removeEventListener("pointerup", onPointerUp);
      }

      function animate() {
        requestAnimationFrame(animate);
        render();
      }

      function render() {
        group.rotation.y += (targetRotation - group.rotation.y) * 0.05;
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
